schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "auction"
"""
type auction {
  id: bigint!
  price: bigint!
  trader: String!
}

"""
aggregated selection of "auction"
"""
type auction_aggregate {
  aggregate: auction_aggregate_fields
  nodes: [auction!]!
}

"""
aggregate fields of "auction"
"""
type auction_aggregate_fields {
  avg: auction_avg_fields
  count(columns: [auction_select_column!], distinct: Boolean): Int!
  max: auction_max_fields
  min: auction_min_fields
  stddev: auction_stddev_fields
  stddev_pop: auction_stddev_pop_fields
  stddev_samp: auction_stddev_samp_fields
  sum: auction_sum_fields
  var_pop: auction_var_pop_fields
  var_samp: auction_var_samp_fields
  variance: auction_variance_fields
}

"""aggregate avg on columns"""
type auction_avg_fields {
  id: Float
  price: Float
}

"""
Boolean expression to filter rows from the table "auction". All fields are combined with a logical 'AND'.
"""
input auction_bool_exp {
  _and: [auction_bool_exp!]
  _not: auction_bool_exp
  _or: [auction_bool_exp!]
  id: bigint_comparison_exp
  price: bigint_comparison_exp
  trader: String_comparison_exp
}

"""aggregate max on columns"""
type auction_max_fields {
  id: bigint
  price: bigint
  trader: String
}

"""aggregate min on columns"""
type auction_min_fields {
  id: bigint
  price: bigint
  trader: String
}

"""Ordering options when selecting data from "auction"."""
input auction_order_by {
  id: order_by
  price: order_by
  trader: order_by
}

"""
select columns of table "auction"
"""
enum auction_select_column {
  """column name"""
  id

  """column name"""
  price

  """column name"""
  trader
}

"""aggregate stddev on columns"""
type auction_stddev_fields {
  id: Float
  price: Float
}

"""aggregate stddev_pop on columns"""
type auction_stddev_pop_fields {
  id: Float
  price: Float
}

"""aggregate stddev_samp on columns"""
type auction_stddev_samp_fields {
  id: Float
  price: Float
}

"""aggregate sum on columns"""
type auction_sum_fields {
  id: bigint
  price: bigint
}

"""aggregate var_pop on columns"""
type auction_var_pop_fields {
  id: Float
  price: Float
}

"""aggregate var_samp on columns"""
type auction_var_samp_fields {
  id: Float
  price: Float
}

"""aggregate variance on columns"""
type auction_variance_fields {
  id: Float
  price: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "dipdup_contract"
"""
type dipdup_contract {
  address: String!
  created_at: timestamptz!
  name: String!
  typename: String
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_contract"
"""
type dipdup_contract_aggregate {
  aggregate: dipdup_contract_aggregate_fields
  nodes: [dipdup_contract!]!
}

"""
aggregate fields of "dipdup_contract"
"""
type dipdup_contract_aggregate_fields {
  count(columns: [dipdup_contract_select_column!], distinct: Boolean): Int!
  max: dipdup_contract_max_fields
  min: dipdup_contract_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_contract". All fields are combined with a logical 'AND'.
"""
input dipdup_contract_bool_exp {
  _and: [dipdup_contract_bool_exp!]
  _not: dipdup_contract_bool_exp
  _or: [dipdup_contract_bool_exp!]
  address: String_comparison_exp
  created_at: timestamptz_comparison_exp
  name: String_comparison_exp
  typename: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_contract_max_fields {
  address: String
  created_at: timestamptz
  name: String
  typename: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_contract_min_fields {
  address: String
  created_at: timestamptz
  name: String
  typename: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_contract"."""
input dipdup_contract_order_by {
  address: order_by
  created_at: order_by
  name: order_by
  typename: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_contract"
"""
enum dipdup_contract_select_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  typename

  """column name"""
  updated_at
}

"""
columns and relationships of "dipdup_head"
"""
type dipdup_head {
  created_at: timestamptz!
  hash: String!
  level: Int!
  name: String!
  timestamp: timestamptz!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_head"
"""
type dipdup_head_aggregate {
  aggregate: dipdup_head_aggregate_fields
  nodes: [dipdup_head!]!
}

"""
aggregate fields of "dipdup_head"
"""
type dipdup_head_aggregate_fields {
  avg: dipdup_head_avg_fields
  count(columns: [dipdup_head_select_column!], distinct: Boolean): Int!
  max: dipdup_head_max_fields
  min: dipdup_head_min_fields
  stddev: dipdup_head_stddev_fields
  stddev_pop: dipdup_head_stddev_pop_fields
  stddev_samp: dipdup_head_stddev_samp_fields
  sum: dipdup_head_sum_fields
  var_pop: dipdup_head_var_pop_fields
  var_samp: dipdup_head_var_samp_fields
  variance: dipdup_head_variance_fields
}

"""aggregate avg on columns"""
type dipdup_head_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_head". All fields are combined with a logical 'AND'.
"""
input dipdup_head_bool_exp {
  _and: [dipdup_head_bool_exp!]
  _not: dipdup_head_bool_exp
  _or: [dipdup_head_bool_exp!]
  created_at: timestamptz_comparison_exp
  hash: String_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_head_max_fields {
  created_at: timestamptz
  hash: String
  level: Int
  name: String
  timestamp: timestamptz
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_head_min_fields {
  created_at: timestamptz
  hash: String
  level: Int
  name: String
  timestamp: timestamptz
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_head"."""
input dipdup_head_order_by {
  created_at: order_by
  hash: order_by
  level: order_by
  name: order_by
  timestamp: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_head"
"""
enum dipdup_head_select_column {
  """column name"""
  created_at

  """column name"""
  hash

  """column name"""
  level

  """column name"""
  name

  """column name"""
  timestamp

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type dipdup_head_stddev_fields {
  level: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_head_stddev_pop_fields {
  level: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_head_stddev_samp_fields {
  level: Float
}

"""aggregate sum on columns"""
type dipdup_head_sum_fields {
  level: Int
}

"""aggregate var_pop on columns"""
type dipdup_head_var_pop_fields {
  level: Float
}

"""aggregate var_samp on columns"""
type dipdup_head_var_samp_fields {
  level: Float
}

"""aggregate variance on columns"""
type dipdup_head_variance_fields {
  level: Float
}

"""
columns and relationships of "dipdup_index"
"""
type dipdup_index {
  config_hash: String!
  created_at: timestamptz!
  level: Int!
  name: String!

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String!
  template: String
  template_values(
    """JSON select path"""
    path: String
  ): jsonb

  """operation: operation\nbig_map: big_map\nhead: head"""
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_index"
"""
type dipdup_index_aggregate {
  aggregate: dipdup_index_aggregate_fields
  nodes: [dipdup_index!]!
}

"""
aggregate fields of "dipdup_index"
"""
type dipdup_index_aggregate_fields {
  avg: dipdup_index_avg_fields
  count(columns: [dipdup_index_select_column!], distinct: Boolean): Int!
  max: dipdup_index_max_fields
  min: dipdup_index_min_fields
  stddev: dipdup_index_stddev_fields
  stddev_pop: dipdup_index_stddev_pop_fields
  stddev_samp: dipdup_index_stddev_samp_fields
  sum: dipdup_index_sum_fields
  var_pop: dipdup_index_var_pop_fields
  var_samp: dipdup_index_var_samp_fields
  variance: dipdup_index_variance_fields
}

"""aggregate avg on columns"""
type dipdup_index_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_index". All fields are combined with a logical 'AND'.
"""
input dipdup_index_bool_exp {
  _and: [dipdup_index_bool_exp!]
  _not: dipdup_index_bool_exp
  _or: [dipdup_index_bool_exp!]
  config_hash: String_comparison_exp
  created_at: timestamptz_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
  status: String_comparison_exp
  template: String_comparison_exp
  template_values: jsonb_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_index_max_fields {
  config_hash: String
  created_at: timestamptz
  level: Int
  name: String

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String
  template: String

  """operation: operation\nbig_map: big_map\nhead: head"""
  type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_index_min_fields {
  config_hash: String
  created_at: timestamptz
  level: Int
  name: String

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String
  template: String

  """operation: operation\nbig_map: big_map\nhead: head"""
  type: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_index"."""
input dipdup_index_order_by {
  config_hash: order_by
  created_at: order_by
  level: order_by
  name: order_by
  status: order_by
  template: order_by
  template_values: order_by
  type: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_index"
"""
enum dipdup_index_select_column {
  """column name"""
  config_hash

  """column name"""
  created_at

  """column name"""
  level

  """column name"""
  name

  """column name"""
  status

  """column name"""
  template

  """column name"""
  template_values

  """column name"""
  type

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type dipdup_index_stddev_fields {
  level: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_index_stddev_pop_fields {
  level: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_index_stddev_samp_fields {
  level: Float
}

"""aggregate sum on columns"""
type dipdup_index_sum_fields {
  level: Int
}

"""aggregate var_pop on columns"""
type dipdup_index_var_pop_fields {
  level: Float
}

"""aggregate var_samp on columns"""
type dipdup_index_var_samp_fields {
  level: Float
}

"""aggregate variance on columns"""
type dipdup_index_variance_fields {
  level: Float
}

"""
columns and relationships of "dipdup_schema"
"""
type dipdup_schema {
  created_at: timestamptz!
  hash: String!
  name: String!

  """
  MANUAL: triggered manually from callback\nMIGRATION: applied migration requires reindexing\nROLLBACK: reorg message received and can't be processed\nCONFIG_HASH_MISMATCH: index config has been modified\nSCHEMA_HASH_MISMATCH: database schema has been modified\nBLOCK_HASH_MISMATCH: block hash mismatch, missed rollback when DipDup was stopped\nMISSING_INDEX_TEMPLATE: index template is missing, can't restore index state
  """
  reindex: String
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_schema"
"""
type dipdup_schema_aggregate {
  aggregate: dipdup_schema_aggregate_fields
  nodes: [dipdup_schema!]!
}

"""
aggregate fields of "dipdup_schema"
"""
type dipdup_schema_aggregate_fields {
  count(columns: [dipdup_schema_select_column!], distinct: Boolean): Int!
  max: dipdup_schema_max_fields
  min: dipdup_schema_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_schema". All fields are combined with a logical 'AND'.
"""
input dipdup_schema_bool_exp {
  _and: [dipdup_schema_bool_exp!]
  _not: dipdup_schema_bool_exp
  _or: [dipdup_schema_bool_exp!]
  created_at: timestamptz_comparison_exp
  hash: String_comparison_exp
  name: String_comparison_exp
  reindex: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_schema_max_fields {
  created_at: timestamptz
  hash: String
  name: String

  """
  MANUAL: triggered manually from callback\nMIGRATION: applied migration requires reindexing\nROLLBACK: reorg message received and can't be processed\nCONFIG_HASH_MISMATCH: index config has been modified\nSCHEMA_HASH_MISMATCH: database schema has been modified\nBLOCK_HASH_MISMATCH: block hash mismatch, missed rollback when DipDup was stopped\nMISSING_INDEX_TEMPLATE: index template is missing, can't restore index state
  """
  reindex: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_schema_min_fields {
  created_at: timestamptz
  hash: String
  name: String

  """
  MANUAL: triggered manually from callback\nMIGRATION: applied migration requires reindexing\nROLLBACK: reorg message received and can't be processed\nCONFIG_HASH_MISMATCH: index config has been modified\nSCHEMA_HASH_MISMATCH: database schema has been modified\nBLOCK_HASH_MISMATCH: block hash mismatch, missed rollback when DipDup was stopped\nMISSING_INDEX_TEMPLATE: index template is missing, can't restore index state
  """
  reindex: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_schema"."""
input dipdup_schema_order_by {
  created_at: order_by
  hash: order_by
  name: order_by
  reindex: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_schema"
"""
enum dipdup_schema_select_column {
  """column name"""
  created_at

  """column name"""
  hash

  """column name"""
  name

  """column name"""
  reindex

  """column name"""
  updated_at
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "meta"
"""
type meta {
  category: String
  collection_id: Int
  collection_name: String
  creator: String
  creator_name: String
  creator_royalty: Int
  decimals: Int
  edition_number: Int
  editions: Int
  id: String!
  ipfs_hash: String
  keywords: String
  name: String
  on_auction: String
  on_sale: String
  owner: String
  price: String
  symbol: String
  token_id: Int
}

"""
aggregated selection of "meta"
"""
type meta_aggregate {
  aggregate: meta_aggregate_fields
  nodes: [meta!]!
}

"""
aggregate fields of "meta"
"""
type meta_aggregate_fields {
  avg: meta_avg_fields
  count(columns: [meta_select_column!], distinct: Boolean): Int!
  max: meta_max_fields
  min: meta_min_fields
  stddev: meta_stddev_fields
  stddev_pop: meta_stddev_pop_fields
  stddev_samp: meta_stddev_samp_fields
  sum: meta_sum_fields
  var_pop: meta_var_pop_fields
  var_samp: meta_var_samp_fields
  variance: meta_variance_fields
}

"""aggregate avg on columns"""
type meta_avg_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""
Boolean expression to filter rows from the table "meta". All fields are combined with a logical 'AND'.
"""
input meta_bool_exp {
  _and: [meta_bool_exp!]
  _not: meta_bool_exp
  _or: [meta_bool_exp!]
  category: String_comparison_exp
  collection_id: Int_comparison_exp
  collection_name: String_comparison_exp
  creator: String_comparison_exp
  creator_name: String_comparison_exp
  creator_royalty: Int_comparison_exp
  decimals: Int_comparison_exp
  edition_number: Int_comparison_exp
  editions: Int_comparison_exp
  id: String_comparison_exp
  ipfs_hash: String_comparison_exp
  keywords: String_comparison_exp
  name: String_comparison_exp
  on_auction: String_comparison_exp
  on_sale: String_comparison_exp
  owner: String_comparison_exp
  price: String_comparison_exp
  symbol: String_comparison_exp
  token_id: Int_comparison_exp
}

"""aggregate max on columns"""
type meta_max_fields {
  category: String
  collection_id: Int
  collection_name: String
  creator: String
  creator_name: String
  creator_royalty: Int
  decimals: Int
  edition_number: Int
  editions: Int
  id: String
  ipfs_hash: String
  keywords: String
  name: String
  on_auction: String
  on_sale: String
  owner: String
  price: String
  symbol: String
  token_id: Int
}

"""aggregate min on columns"""
type meta_min_fields {
  category: String
  collection_id: Int
  collection_name: String
  creator: String
  creator_name: String
  creator_royalty: Int
  decimals: Int
  edition_number: Int
  editions: Int
  id: String
  ipfs_hash: String
  keywords: String
  name: String
  on_auction: String
  on_sale: String
  owner: String
  price: String
  symbol: String
  token_id: Int
}

"""Ordering options when selecting data from "meta"."""
input meta_order_by {
  category: order_by
  collection_id: order_by
  collection_name: order_by
  creator: order_by
  creator_name: order_by
  creator_royalty: order_by
  decimals: order_by
  edition_number: order_by
  editions: order_by
  id: order_by
  ipfs_hash: order_by
  keywords: order_by
  name: order_by
  on_auction: order_by
  on_sale: order_by
  owner: order_by
  price: order_by
  symbol: order_by
  token_id: order_by
}

"""
select columns of table "meta"
"""
enum meta_select_column {
  """column name"""
  category

  """column name"""
  collection_id

  """column name"""
  collection_name

  """column name"""
  creator

  """column name"""
  creator_name

  """column name"""
  creator_royalty

  """column name"""
  decimals

  """column name"""
  edition_number

  """column name"""
  editions

  """column name"""
  id

  """column name"""
  ipfs_hash

  """column name"""
  keywords

  """column name"""
  name

  """column name"""
  on_auction

  """column name"""
  on_sale

  """column name"""
  owner

  """column name"""
  price

  """column name"""
  symbol

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type meta_stddev_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""aggregate stddev_pop on columns"""
type meta_stddev_pop_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""aggregate stddev_samp on columns"""
type meta_stddev_samp_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""aggregate sum on columns"""
type meta_sum_fields {
  collection_id: Int
  creator_royalty: Int
  decimals: Int
  edition_number: Int
  editions: Int
  token_id: Int
}

"""aggregate var_pop on columns"""
type meta_var_pop_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""aggregate var_samp on columns"""
type meta_var_samp_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""aggregate variance on columns"""
type meta_variance_fields {
  collection_id: Float
  creator_royalty: Float
  decimals: Float
  edition_number: Float
  editions: Float
  token_id: Float
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "auction"
  """
  auction(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """
  fetch aggregated fields from the table: "auction"
  """
  auction_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!

  """fetch data from the table: "auction" using primary key columns"""
  auction_by_pk(trader: String!): auction

  """
  fetch data from the table: "dipdup_contract"
  """
  dipdup_contract(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): [dipdup_contract!]!

  """
  fetch aggregated fields from the table: "dipdup_contract"
  """
  dipdup_contract_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): dipdup_contract_aggregate!

  """fetch data from the table: "dipdup_contract" using primary key columns"""
  dipdup_contract_by_pk(name: String!): dipdup_contract

  """
  fetch data from the table: "dipdup_head"
  """
  dipdup_head(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): [dipdup_head!]!

  """
  fetch aggregated fields from the table: "dipdup_head"
  """
  dipdup_head_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): dipdup_head_aggregate!

  """fetch data from the table: "dipdup_head" using primary key columns"""
  dipdup_head_by_pk(name: String!): dipdup_head

  """
  fetch data from the table: "dipdup_index"
  """
  dipdup_index(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): [dipdup_index!]!

  """
  fetch aggregated fields from the table: "dipdup_index"
  """
  dipdup_index_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): dipdup_index_aggregate!

  """fetch data from the table: "dipdup_index" using primary key columns"""
  dipdup_index_by_pk(name: String!): dipdup_index

  """
  fetch data from the table: "dipdup_schema"
  """
  dipdup_schema(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): [dipdup_schema!]!

  """
  fetch aggregated fields from the table: "dipdup_schema"
  """
  dipdup_schema_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): dipdup_schema_aggregate!

  """fetch data from the table: "dipdup_schema" using primary key columns"""
  dipdup_schema_by_pk(name: String!): dipdup_schema

  """
  fetch data from the table: "meta"
  """
  meta(
    """distinct select on columns"""
    distinct_on: [meta_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meta_order_by!]

    """filter the rows returned"""
    where: meta_bool_exp
  ): [meta!]!

  """
  fetch aggregated fields from the table: "meta"
  """
  meta_aggregate(
    """distinct select on columns"""
    distinct_on: [meta_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meta_order_by!]

    """filter the rows returned"""
    where: meta_bool_exp
  ): meta_aggregate!

  """fetch data from the table: "meta" using primary key columns"""
  meta_by_pk(id: String!): meta

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: bigint!): token
}

type subscription_root {
  """
  fetch data from the table: "auction"
  """
  auction(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """
  fetch aggregated fields from the table: "auction"
  """
  auction_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!

  """fetch data from the table: "auction" using primary key columns"""
  auction_by_pk(trader: String!): auction

  """
  fetch data from the table: "dipdup_contract"
  """
  dipdup_contract(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): [dipdup_contract!]!

  """
  fetch aggregated fields from the table: "dipdup_contract"
  """
  dipdup_contract_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): dipdup_contract_aggregate!

  """fetch data from the table: "dipdup_contract" using primary key columns"""
  dipdup_contract_by_pk(name: String!): dipdup_contract

  """
  fetch data from the table: "dipdup_head"
  """
  dipdup_head(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): [dipdup_head!]!

  """
  fetch aggregated fields from the table: "dipdup_head"
  """
  dipdup_head_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): dipdup_head_aggregate!

  """fetch data from the table: "dipdup_head" using primary key columns"""
  dipdup_head_by_pk(name: String!): dipdup_head

  """
  fetch data from the table: "dipdup_index"
  """
  dipdup_index(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): [dipdup_index!]!

  """
  fetch aggregated fields from the table: "dipdup_index"
  """
  dipdup_index_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): dipdup_index_aggregate!

  """fetch data from the table: "dipdup_index" using primary key columns"""
  dipdup_index_by_pk(name: String!): dipdup_index

  """
  fetch data from the table: "dipdup_schema"
  """
  dipdup_schema(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): [dipdup_schema!]!

  """
  fetch aggregated fields from the table: "dipdup_schema"
  """
  dipdup_schema_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): dipdup_schema_aggregate!

  """fetch data from the table: "dipdup_schema" using primary key columns"""
  dipdup_schema_by_pk(name: String!): dipdup_schema

  """
  fetch data from the table: "meta"
  """
  meta(
    """distinct select on columns"""
    distinct_on: [meta_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meta_order_by!]

    """filter the rows returned"""
    where: meta_bool_exp
  ): [meta!]!

  """
  fetch aggregated fields from the table: "meta"
  """
  meta_aggregate(
    """distinct select on columns"""
    distinct_on: [meta_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meta_order_by!]

    """filter the rows returned"""
    where: meta_bool_exp
  ): meta_aggregate!

  """fetch data from the table: "meta" using primary key columns"""
  meta_by_pk(id: String!): meta

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: bigint!): token
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "token"
"""
type token {
  collection: String!
  creator: String!
  id: bigint!
  ipfs: String!
  price: bigint!
  sale: String!
  trader: String!
}

"""
aggregated selection of "token"
"""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

"""
aggregate fields of "token"
"""
type token_aggregate_fields {
  avg: token_avg_fields
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
  stddev: token_stddev_fields
  stddev_pop: token_stddev_pop_fields
  stddev_samp: token_stddev_samp_fields
  sum: token_sum_fields
  var_pop: token_var_pop_fields
  var_samp: token_var_samp_fields
  variance: token_variance_fields
}

"""aggregate avg on columns"""
type token_avg_fields {
  id: Float
  price: Float
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  collection: String_comparison_exp
  creator: String_comparison_exp
  id: bigint_comparison_exp
  ipfs: String_comparison_exp
  price: bigint_comparison_exp
  sale: String_comparison_exp
  trader: String_comparison_exp
}

"""aggregate max on columns"""
type token_max_fields {
  collection: String
  creator: String
  id: bigint
  ipfs: String
  price: bigint
  sale: String
  trader: String
}

"""aggregate min on columns"""
type token_min_fields {
  collection: String
  creator: String
  id: bigint
  ipfs: String
  price: bigint
  sale: String
  trader: String
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  collection: order_by
  creator: order_by
  id: order_by
  ipfs: order_by
  price: order_by
  sale: order_by
  trader: order_by
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  collection

  """column name"""
  creator

  """column name"""
  id

  """column name"""
  ipfs

  """column name"""
  price

  """column name"""
  sale

  """column name"""
  trader
}

"""aggregate stddev on columns"""
type token_stddev_fields {
  id: Float
  price: Float
}

"""aggregate stddev_pop on columns"""
type token_stddev_pop_fields {
  id: Float
  price: Float
}

"""aggregate stddev_samp on columns"""
type token_stddev_samp_fields {
  id: Float
  price: Float
}

"""aggregate sum on columns"""
type token_sum_fields {
  id: bigint
  price: bigint
}

"""aggregate var_pop on columns"""
type token_var_pop_fields {
  id: Float
  price: Float
}

"""aggregate var_samp on columns"""
type token_var_samp_fields {
  id: Float
  price: Float
}

"""aggregate variance on columns"""
type token_variance_fields {
  id: Float
  price: Float
}